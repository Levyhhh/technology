# 面向对象设计（Object - Oriented Design，OOD）

## SOLID 原则

-
    1. **单一职责原则（Single - Responsibility Principle，SRP）**
        - **定义**：一个类应该只有一个引起它变化的原因，即一个类只负责一项职责。如果一个类承担了过多的职责，那么这些职责中的任何一个发生变化都可能导致这个类需要修改。这样的类就会变得复杂且难以维护。
        - **示例**：考虑一个简单的银行账户类。它可能有存款、取款和查询余额的方法。如果这个类还负责打印账户报表和处理贷款申请，那么它就承担了太多职责。更好的做法是将打印报表和处理贷款申请的功能分离到其他类中，这样当报表格式或贷款政策发生变化时，不会影响到账户的基本操作类。
        - **优点**：使得代码更加清晰、易读和易于维护。每个类的职责明确，开发人员可以更容易地理解和修改类的功能，而且一个职责的变化不会对其他不相关的职责产生影响，降低了代码的耦合度。
    2. **开闭原则（Open - Closed Principle，OCP）**
        - **定义**：软件实体（如类、模块、函数等）应该对扩展开放，对修改关闭。这意味着在不修改原有代码的前提下，可以通过扩展代码来实现新的功能。
        - **示例**：以图形绘制软件为例。假设有一个绘制基本图形的类库，其中有一个绘制圆形的类。如果要添加绘制矩形的功能，不应该修改绘制圆形的类，而是通过创建一个新的绘制矩形的类来扩展类库的功能。这样，原有绘制圆形的代码不会被破坏，并且可以通过添加新的类来满足新的绘图需求。
        - **优点**：有助于提高软件的可维护性和可扩展性。它可以降低修改代码带来的风险，因为修改原有代码可能会引入新的错误或者影响已经实现的功能。通过遵循开闭原则，开发人员可以在不破坏现有系统的情况下，轻松地添加新功能。
    3. **里氏替换原则（Liskov Substitution Principle，LSP）**
        - **定义**：子类型必须能够替换它们的基类型。在任何使用基类对象的地方，都可以用子类对象来替换，并且程序的行为不会发生改变。这是继承复用的基石，保证了继承关系的正确性和一致性。
        - **示例**：假设有一个基类`Vehicle`，有一个方法`startEngine`。有两个子类`Car`和`Motorcycle`。按照里氏替换原则，在任何使用`Vehicle`对象调用`startEngine`方法的地方，如在一个交通模拟程序中，如果用`Car`或`Motorcycle`对象替换`Vehicle`对象，程序应该能够正常运行，并且`startEngine`方法的调用在语义上是合理的。
        - **优点**：确保了代码的多态性能够正确实现，使得继承关系更加可靠。在进行面向对象编程时，能够保证基于基类设计的程序在使用子类替换基类时不会出现逻辑错误，提高了代码的健壮性。
    4. **接口隔离原则（Interface - Segregation Principle，ISP）**
        - **定义**：客户端不应该被迫依赖于它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。这避免了接口的臃肿和不必要的实现，降低了代码的耦合度。
        - **示例**：假设有一个多功能打印机接口，包括打印、扫描、复印和传真功能。但如果有一个简单的打印设备，它只需要实现打印功能。按照接口隔离原则，应该将多功能打印机接口拆分成打印接口、扫描接口、复印接口和传真接口，让简单的打印设备只实现打印接口，避免了实现不需要的功能接口。
        - **优点**：使得接口更加专注于特定的功能，客户端只需要关注自己需要的接口部分。这提高了代码的灵活性和可维护性，减少了不必要的代码实现，同时也方便了接口的复用。
    5. **依赖倒置原则（Dependency - Inversion Principle，DIP）**
        - **定义**：高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。这意味着在软件设计中，应该尽量依赖抽象类型（如接口或抽象类），而不是具体的实现类。
        - **示例**：在一个电商系统中，订单处理模块（高层模块）不应该直接依赖数据库访问模块（低层模块）。而是应该定义一个数据访问抽象接口，订单处理模块依赖这个抽象接口，数据库访问模块实现这个抽象接口。这样，当数据库访问方式需要改变（如从关系型数据库改为非关系型数据库）时，只需要修改数据库访问模块的实现，而不会影响订单处理模块。
        - **优点**：降低了模块之间的耦合度，使得系统更加灵活和易于维护。通过依赖抽象，高层模块可以独立于低层模块的具体实现进行开发和测试，并且在需要替换低层模块时更加方便。
